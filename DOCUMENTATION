MMR: A Tool for Read Multi-Mapper Resolution

Motivation

Mapping high throughput sequencing data to a reference genome is an
essential step for most analysis pipelines aiming at the computational
analysis of genome and transcriptome sequencing data. Breaking ties
between equally likely mapping locations still poses a severe problem
not only during the alignment phase but also has significant impact
how the data can be used for further analyses. We present the
multimapper resolution (MMR) tool that infers the best mapping
location only on the distribution of mapped reads.

Principle

We follow a simple strategy that locally minimizes the variability
("roughness") of position-wise coverage within a window of given
length.  By comparing the local "roughness" around two possible
alignments/mappings of the same read, we can iteratively select the
best alignments/mappings for all reads to obtain "smooth" coverage
everywhere. Additional information, such as transcript structure, to
accounting for expected differences in local coverage can be
incorporated. 


Common Usage

The tool takes a read alignment file in BAM format as input. The input 
BAM file is assumed to have multiple alignments per read.
The output is a new BAM file that has selected alignment marked in the 
tags. If one uses the -b option, at most one alignment will be saved per 
read which can lead to a significant file size reduction.
The individual arguments are described below.


Usage:
	./mmr -o OUTFILE [options] IN_BAM

Available Options:


	Input handling and paralellization:
	-P --parse-complete 	parse complete file into memory [off]
	-t --threads 		number of threads to use (must be > 2) [1]
	-S --strand-specific 	alignments are strand specific [off]
	-C --init-secondary  	choose initial alignment also from secondary lines (flag 256) [off]

	Input file filtering:
	-f --pre-filter-off 	switch off pre filter for alignments that have F more edit ops than the best [on]
	-F --filter-dist [INT]	filter distance F for pre-filter [1]
	-V --use-variants 	use variant alignments for filtering (different edit op count,
				requires XG and XM Tag in alignment files) [off]
	-L --max-list-length [INT]	max length of alignment list per read (after filtering) [1000]

	Paired alignment handling:
	-p --pair-usage 	pre use pair information in the reads [off]
	-i --max-fragment-size 	upper limit of GENOMIC fragment length [1 000 000]
	-A --max-pair-list-length [INT]	max no of valid pairs before not using pair modus [10000]

	Output handling:
	-b --best-only 		print only best alignment [off]

	Options for using the variance optimization:
	-w --windowsize  [INT]	size of coverage window around read [20]
	-I --iterations  [INT]	number of iterations to smooth the coverage [5]

	Options for using the MiTie objective for smoothing:
	-m --mitie-objective 	use objective from MiTie instead of local variance [off]
	-s --segmentfile 	MiTie segment file required for MiTie optimization []
	-l --lossfile 		MiTie loss parameter file required for MiTie optimization []
	-r --read-len  [INT]	average length of the reads [75]
	-M --mitie-variance 	use variance smoothing for regions with no MiTie prediction [off]
	-z --zero-expect-unpred 	initializes all covered but not predicted positions with expectation 0.0 [off]

	General:
	-v --verbose 		switch on verbose output [off]
	-h --help 		print usage info

